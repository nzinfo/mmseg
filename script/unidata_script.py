# -*- coding: utf-8 -*-
#!/usr/bin/env python
"""
    处理 Unicode 规范中，定义的 Script;
    用于支持字符类型， 如 数字 | 英文 等
    需要额外追加类型  ？ 暂时先不考虑

    因为 文字的类型 + 子类型已经超过 2**11， 需要额外的码表进行转换

    生成 代码映射需要的头文件
"""
import sys
import codecs

g_max_icode = 0

def get_icode(s):
    global g_max_icode

    v = 0
    s = '0x'+s
    v = eval(s)

    if v > g_max_icode:
        g_max_icode = v
    return v

class UniDataScript(object):

    def __init__(self):
        self._chars = {}
        self._ct = {}

    def reset(self):
        self._chars = {}
        self._ct = {}

    def add_char(self, iCode, annote ):
        self._chars[iCode] = annote

    def add_char_range(self, iCodeBegin, iCodeEnd, annote ):
        for iCode in range(iCodeBegin, iCodeEnd +1):
            self._chars[iCode] = annote

    def load_text(self, fname, ct={}):

        def proc_single_char(line):
            lend = line.find(';')
            p = line[:lend].strip()
            src = get_icode( p.strip() )

            sharp_pos = line.find('#')
            sub_type = line[sharp_pos:sharp_pos+4].strip()
            script_type = line[line.find(';')+1:sharp_pos].strip()
            #print script_type, sub_type
            if script_type not in self._ct:
                self._ct[script_type] = {}
                self._ct[script_type][sub_type] = 1
            else:
                if sub_type not in self._ct[script_type]:
                    self._ct[script_type][sub_type] = 1
            k = get_tag_key(script_type, sub_type)
            if k in ct:
                self.add_char(src, ct[k])
            else:
                self.add_char(src, line)

        def proc_range_char(line):
            lbegin = line.find('..')
            lend = line.find(';')
            p = line[:lend].strip()
            #print p
            srcbegin = get_icode( p[:lbegin].strip() )
            srcend = get_icode( p[lbegin+2:].strip() )
            #print srcbegin, srcend

            sharp_pos = line.find('#')
            sub_type = line[sharp_pos:sharp_pos+4].strip()
            script_type = line[line.find(';')+1:sharp_pos].strip()
            #print script_type, sub_type
            if script_type not in self._ct:
                self._ct[script_type] = {}
                self._ct[script_type][sub_type] = 1
            else:
                if sub_type not in self._ct[script_type]:
                    self._ct[script_type][sub_type] = 1
            k = get_tag_key(script_type, sub_type)
            #print k , k in ct
            if k in ct:
                self.add_char_range(srcbegin, srcend, ct[k])
            else:
                self.add_char_range(srcbegin, srcend, line)

        with codecs.open(fname, "r", "UTF-8") as fh:
            for line in fh:
                line = line.strip()
                if not line:
                    continue
                if line[0] == '#':
                    continue
                if line.find('..') == -1:
                    proc_single_char(line)
                else:
                    proc_range_char(line)
        pass

    def query(self, c):
        iCode = ord(c)
        #print self._chars
        print c,
        return iCode, self._chars[iCode]
        #print unichr(iCode)

    def query_code(self, iCode):
        return self._chars[iCode]

def get_tag_key(script_type, tag_type):
    key = script_type
    k = tag_type
    k=k.replace('#', '')
    k=k.replace('&', '')
    tag_key = "%s_%s" % (key.strip(), k.strip())
    tag_key = tag_key.upper()
    return tag_key

def generate_tag_define(ct, fname):
    char_tag = {}
    with open(fname, 'w') as fh:
        fh.write("""#ifndef MM_CHARTAG_MAP_H_
#define MM_CHARTAG_MAP_H_
/* Autogenerated by unidata_script.py, do not edit this file. */
        \n""")
        i = 10
        map = [(x,x) for x in range(0, 10)]

        for key in ct.keys():
            key_start = i
            for k in ct[key]:
                tag_key = get_tag_key(key, k)
                fh.write( "#define %s\t%d\n" % (tag_key, i) )
                char_tag[tag_key] = i
                map.append( (i, key_start ) )
                i += 1
            key_end = i
            fh.write("#define IS_%s(x) \t ((%d<=x)&&(x<%d)) \n\n" % (key.strip().upper(), key_start, key_end) )
            #print key_start, key_end

        # generate tag -> script type lookup.
        fh.write("unsigned short tag2script_map[] = { \n")
        for i in range(0, len(map)):
            s, d = map[i]
            fh.write( "%d, " % d )
            if i % 15 == 14:
                fh.write('\n')
        fh.write("%d };\n\n" % i) # the last entry should never been meet.
        fh.write("#endif\n\n")
    return char_tag

if __name__ == "__main__":
    import sys
    fname = sys.argv[1]

    d = UniDataScript()
    d.load_text(fname)
    print d.query(u"中")
    print d.query(u"一")
    print d.query(u"1")
    print d.query(u"１")
    print d.query(u"①")
    print d.query(u"⒈")
    print d.query(u"。")
    print d.query(u".")
    print d.query(u"?")
    print d.query(u"'")
    print d.query(u">")
    print d.query(u"A")
    print d.query(u"a")
    print d.query(u"Ａ")
    print d.query(u"-")

    print d.query_code(ord('z') +1)
    #print d._ct
    print len(d._ct)
    print d._ct['Han']
    #print d._ct.keys()
    ct = generate_tag_define(d._ct, "chartag_def.h")
    d.reset()
    #print ct
    d.load_text(fname, ct)
    print d.query(u"中")
    # 102 25
# -*- end of file -*-